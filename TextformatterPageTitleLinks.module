<?php
namespace Processwire;

class TextformatterPageTitleLinks extends Textformatter implements Module
{
    const CACHE_NAMESPACE = 'TextformatterPageTitleLinks-';

    /**
     * @var ?array $title_id_array Holds the array with titles of ids for this request.
     */
    private static $title_id_array = null;

    public static function getModuleInfo(): array
    {
        return [
            'title' => __('Automatically link page titles'),
            'summary' => __('This converts all page titles to a link to the corresponding page.'),
            'author' => 'Moritz L\'Hoest, herebedragons.world',
            'version' => '0.4.0',
            'requires' => [
                'PHP>=7.0.0'
            ]
        ];
    }

    public function format(&$str)
    {
        $this->formatValue($this->wire('page'), new Field(), $str);
    }

    public function formatValue(Page $page, Field $field, &$value)
    {
        // no templates set yet
        if (empty($this->auto_link_templates)) {
            return;
        }

        // if this is a repeater (matrix) page, make sure
        // $page references the "real" current page
        if (
            $page instanceof RepeaterPage ||
            $page instanceof RepeaterMatrixPage
        ) {
            $page = wire('page');
        }

        // get all pages of the selected templates as an associative id => title array
        $id_title_array = $this->getTitleIdArrayFromDatabase();

        // exclude current id from this replacement if the option to include it is not active
        if (!$this->include_current_page) {
            $current_id = (int) $page->id;
            if (!empty($current_id) && array_key_exists($current_id, $id_title_array)) {
                unset($id_title_array[$current_id]);
            }
        }

        // abort if no linkable pages exist at this point
        if (empty($id_title_array)) {
            return;
        }

        $css_class = $this->add_link_class;

        // perform the replacement with a regex call
        $value = preg_replace_callback(
            // format the titles as regex patterns
            array_map(function ($title) {
                return '[(?<![\w])' . preg_quote($title) . '(?![\w])]';
            }, $id_title_array),
            // replace the titles with links to the url to the respective page
            function (array $matches) use ($id_title_array, $css_class) {
                $page_id = array_search($matches[0], $id_title_array);
                $linked_page = $this->pages->get((int) $page_id);
                // finaly check to make sure the user has the right to view this page
                if (!$linked_page->viewable()) {
                    return $matches[0];
                }
                $url = $linked_page->url();
                $class_attribute = !empty($css_class) ? ' class="' . $css_class . '"' : '';
                return '<a href="' . $url . '"' . $class_attribute . '>' . $matches[0] . '</a>';
            },
            $value
        );
    }

    private function getTitleIdArrayFromDatabase(): array
    {
        // only run the database query once per request
        if (null !== $this->title_id_array) {
            return $this->title_id_array;
        }

        // current language row
        $language_row = 'data';
        // detect language support and change the row if
        // the current language is not the default one
        $current_lang = $this->wire('user')->language;
        if (!empty($current_lang) && !$current_lang->isDefault()) {
            $language_row .= $current_lang->id;
        }

        // allowed templates for IN statement
        $allowed_templates = implode(', ', $this->auto_link_templates);

        // unpublished pages will never be linked
        $status_bitmask = Page::statusUnpublished;
        // hidden pages will only be included if the option is set
        if (!$this->include_hidden_pages) {
            $status_bitmask += Page::statusHidden;
        }

        /**
         * The main query to get all titles for matching templates. Caveats:
         * - If multiple pages have the same name, a random one will be selected.
         * - If the language value is NULL, there's currently no fallback to the default language.
         */
        $query = "SELECT
                field_title.pages_id,
                field_title.{$language_row} AS title
            FROM pages
            LEFT JOIN field_title ON pages.id = field_title.pages_id
            WHERE pages.templates_id IN ({$allowed_templates})
            AND pages.status & {$status_bitmask} = 0
            AND field_title.{$language_row} IS NOT NULL
            GROUP BY title
            ORDER BY LENGTH(title)";
        return $this->title_id_array = $this
                            ->wire('database')
                            ->pdo()
                            ->query($query)
                            ->fetchAll(\PDO::FETCH_KEY_PAIR);
    }

    /**
     * Probably not needed any more.
     */

    private function getLastModifiedNamespace(?PageArray $pages = null)
    {
        if (empty($pages)) {
            $pages = $this->wire('pages');
        }
        $timestamp = $pages->findOne('sort=-modified')->modified;
        return self::CACHE_NAMESPACE . $timestamp;
    }
}
