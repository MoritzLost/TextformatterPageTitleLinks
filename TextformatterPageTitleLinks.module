<?php
namespace Processwire;

class TextformatterPageTitleLinks extends Textformatter implements Module
{
    /**
     * @var array $language_titles_cache Holds cached data for getTitleIdArrayForCurrentLanguage().
     */
    private static $language_titles_cache = [];

    /**
     * Get the module info.
     *
     * @return array
     */
    public static function getModuleInfo(): array
    {
        return [
            'title' => __('Automatically link page titles'),
            'summary' => __('This converts all page titles to a link to the corresponding page.'),
            'author' => 'Moritz L\'Hoest, herebedragons.world',
            'version' => '1.0.1',
            'href' => 'https://github.com/MoritzLost/TextformatterPageTitleLinks',
            'icon' => 'link',
            'requires' => [
                'PHP>=7.1.0',
            ]
        ];
    }

    /**
     * Shortcut to $this->formatValue using the current page.
     *
     * @param string $str
     * @return void
     */
    public function format(&$str): void
    {
        $this->formatValue($this->wire('page'), new Field(), $str);
    }

    /**
     * Automatically convert titles of pages in the passed text to links to
     * those pages. check out the module documentation for more information.
     *
     * @param Page $page
     * @param Field $field
     * @param string $value
     * @return void
     */
    public function formatValue(Page $page, Field $field, &$value): void
    {
        // no templates set yet
        if (empty($this->auto_link_templates)) {
            return;
        }

        // if this is a repeater (matrix) page, make sure
        // $page references the "real" current page
        if (
            $page instanceof RepeaterPage ||
            $page instanceof RepeaterMatrixPage
        ) {
            $page = wire('page');
        }

        // get all pages of the selected templates as an associative id => title array
        $id_title_array = $this->getTitleIdArrayForCurrentLanguage();

        // exclude current id from this replacement if the option to include it is not active
        if (!$this->include_current_page) {
            $current_id = (int) $page->id;
            if (!empty($current_id) && array_key_exists($current_id, $id_title_array)) {
                unset($id_title_array[$current_id]);
            }
        }

        // abort if no linkable pages exist at this point
        if (empty($id_title_array)) {
            return;
        }

        // perform the replacement with a regex call
        $value = preg_replace_callback(
            // format the titles as regex patterns
            array_map(function ($title) {
                return '[(?<![\w])' . preg_quote($title) . '(?![\w])]';
            }, $id_title_array),
            // replace the titles with links to the url to the respective page
            function (array $matches) use ($id_title_array) {
                $page_id = array_search($matches[0], $id_title_array);
                $linked_page = $this->pages->get((int) $page_id);
                return $this->buildTitlePageLink($matches[0], $linked_page);
            },
            $value
        );
    }

    /**
     * Gets an array of id => title pairs of all pages that are valid title
     * replacement targets. Will return a cached result after the first call.
     * Uses module configuration to figure out which pages to select.
     *
     * @return array
     */
    private function getTitleIdArrayForCurrentLanguage(): array
    {
        // detect language support
        $language_id = 0;
        $current_lang = $this->wire('user')->language;
        if (!empty($current_lang) && $current_lang instanceof Language) {
            $language_id = $current_lang->id;
        }

        // only run the database query once per request & language
        if (
            array_key_exists($language_id, self::$language_titles_cache) &&
            !empty(self::$language_titles_cache[$language_id])
        ) {
            return self::$language_titles_cache[$language_id];
        }

        $value_column = 'data';
        // change the row if the site has language support and
        // the current language is not the default one
        if ($language_id && !$current_lang->isDefault()) {
            $value_column .= $language_id;
        }

        // allowed templates for IN statement
        $allowed_templates = implode(', ', $this->auto_link_templates);

        // unpublished pages will never be linked
        $status_bitmask = Page::statusUnpublished;
        // hidden pages will only be included if the option is set
        if (!$this->include_hidden_pages) {
            $status_bitmask += Page::statusHidden;
        }

        /**
         * The main query to get all titles for matching templates. Caveats:
         * - If multiple pages have the same name, a random one will be selected.
         * - If the language value is NULL, there's currently no fallback to the default language.
         */
        $query = "SELECT
                field_title.pages_id,
                field_title.{$value_column} AS title
            FROM pages
            LEFT JOIN field_title ON pages.id = field_title.pages_id
            WHERE pages.templates_id IN ({$allowed_templates})
            AND pages.status & {$status_bitmask} = 0
            AND field_title.{$value_column} IS NOT NULL
            GROUP BY title
            ORDER BY LENGTH(title)";
        $titles = $this
                    ->wire('database')
                    ->pdo()
                    ->query($query)
                    ->fetchAll(\PDO::FETCH_KEY_PAIR);
        // add those titles to the language title cache
        self::$language_titles_cache[$language_id] = $titles;
        return self::$language_titles_cache[$language_id];
    }

    /**
     * Return a link pointing to the url of the passed page with the passed
     * title as the link text. Will add link classes based on the module
     * configuration, using the passed page for replacements. May return just
     * the title if the user doesn't have access to view the page.
     *
     * @param string $title The title to use as the link text.
     * @param Page $page The page to use for the link, replacements and access checks.
     * @return string
     */
    private function buildTitlePageLink(string $title, Page $page): string
    {
        // check if the user can view the page, otherwise just return the title as-is
        if (!$page->viewable()) {
            return $title;
        }

        // build url and other attributes
        $url = $page->url();
        $attribute_string = $this->getAttributesString($page);

        return '<a href="' . $url . '"' . $attribute_string . '>' . $title . '</a>';
    }

    private function getAttributesString(?Page $page = null): string
    {
        if (!$this->add_attributes) {
            return '';
        }
        // get all attributes as an array, ignoring empty lines
        $attributes = array_filter(explode(PHP_EOL, $this->add_attributes));
        $attr_filtered = [];
        foreach ($attributes as $attribute) {
            // for attributes without a value (standalone attributes), we simply
            // include it
            if (strpos($attribute, '=') === false) {
                $attr_filtered[] = $attribute;
                continue;
            }
            // only one attribute -> value assignment per line
            if (substr_count($attribute, '=') > 1) {
                throw new \Exception('Each line may contain only one equaly sign (`=`).');
            }
            // extract attribute name and value from the current line
            [$attr_name, $attr_value] = explode('=', $attribute);
            // use the passed page for replacements, if any
            $parsed_value = $page ? $page->getMarkup($attr_value) : $attr_value;
            // special escaping for classes
            if ($attr_name === 'class') {
                $parsed_value = trim(preg_replace('/[^a-zA-Z0-9 _-]/', '_', $parsed_value), ' ');
            } elseif ($attr_name === 'href') {
                // ignore for now, may change later
                continue;
            }
            $attr_filtered[] = $attr_name . '="' . htmlspecialchars($parsed_value, ENT_HTML5, 'UTF-8') . '"';
        }
        return ' ' . implode(' ', $attr_filtered);
    }
}
