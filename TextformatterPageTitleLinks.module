<?php
namespace Processwire;

class TextformatterPageTitleLinks extends Textformatter implements ConfigurableModule, Module
{
    const CACHE_NAMESPACE = 'TextformatterPageTitleLinks-';
    const DEFAULT_SELECTOR = 'has_parent!=2, template!=admin';

    public static function getModuleInfo()
    {
        return [
            'title' => 'Automatically link page titles',
            'summary' => 'This converts all page titles to a link to the corresponding page.',
            'author' => 'Moritz L\'Hoest, herebedragons.world',
            'version' => '0.1.0',
            'requires' => [
                'PHP>=7.0.0'
            ]
        ];
    }

    public static function getModuleConfigInputfields(array $data)
    {
        $wrapper = new InputfieldWrapper();

        // Selector string for pages to auto-link
        $selector = wire()->modules->get('InputfieldText');
        $selector->name = 'selector';
        $selector->label = 'Selector string';
        $selector->description = 'An optional Processwire selector to specify what pages should be considered for automatic page title links. Only pages matching this selector';
        $selector->notes = 'To limit the automatic page titles to one or more templates, use a selector like `template=basic-page|other-template`.';

        if (!empty($data['selector'])) {
            // this validates the selector by passing it to Pages::find as an
            // argument and adding any errors thrown to the inputfield
            try {
                $test_pages = wire('pages')->find($data['selector']);
            } catch (\Throwable $e) {
                $message = 'It looks like this is not a valid selector. Please fix the following error message and try again:' . PHP_EOL;
                $message .= $e->getMessage();
                $selector->error($message);
            }
            $selector->attr('value', $data['selector']);
        } else {
            $selector->attr('value', self::DEFAULT_SELECTOR);
        }

        $wrapper->add($selector);

        return $wrapper;
    }

    public function format(&$str)
    {
        // this doesn't work, should find a better way to cache those results
        // $allowed_pages = $this->cache->getFor(
        //     $this->getLastModifiedNamespace(),
        //     'last_page_modified_time',
        //     WireCache::expireSave,
        //     function () {
        //         return $this->getAllowedPages();
        //     }
        // );

        $allowed_pages = $this->getAllowedPages();
        if (!count($allowed_pages)) {
            $this->log->save('modules', 'The textfilter ' . $this->className() . ' found no pages matching the selector set in the options. Make sure the selector is correct.');
            return;
        }

        // title_id_array is cached, as it's generation is costly
        $title_id_array = $this->cache->getFor(
            $this->getLastModifiedNamespace($allowed_pages),
            'title_id_array',
            WireCache::expireSave,
            function () use ($allowed_pages) {
                return $this->getTitleIdArray($allowed_pages);
            }
        );

        $str = preg_replace_callback(
            array_map(
                function ($title) {
                    return '[' . preg_quote($title) . ']';
                },
                array_keys($title_id_array)
            ),
            function (array $matches) use ($title_id_array) {
                $url = $this->pages->get($title_id_array[$matches[0]])->url();
                return '<a href="' . $url . '">' . $matches[0] . '</a>';
            },
            $str
        );
    }

    public function formatValue(Page $page, Field $field, &$value)
    {
        return $this->format($value);
    }




    private function getAllowedPages()
    {
        $selector = !empty($this->selector) ? $this->selector : self::DEFAULT_SELECTOR;
        return $this->pages->find($selector);
    }

    private function getTitleIdArray(PageArray $pages)
    {
        $title_id_array = [];
        foreach ($pages as $page) {
            if (!empty($page->title)) {
                $title_id_array[$page->title] = $page->id;
            }
        }
        return $title_id_array;
    }

    private function getTitleListForRegex(PageArray $pages)
    {
        $titles = array_column(
            iterator_to_array($pages),
            'title'
        );
        $titles_escaped = array_map(
            function ($title) {
                return preg_quote($title);
            },
            $titles
        );
        $piped_list = implode(
            '|',
            $titles_escaped
        );
        return "({$piped_list})";
    }

    private function getLastModifiedNamespace(?PageArray $pages = NULL)
    {
        if (empty($pages)) {
            $pages = $this->wire('pages');
        }
        $timestamp = $pages->findOne('sort=-modified')->modified;
        return self::CACHE_NAMESPACE . $timestamp;
    }
}
